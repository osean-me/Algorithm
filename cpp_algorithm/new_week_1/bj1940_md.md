두 코드의 성능 차이는 알고리즘의 시간 복잡도와 메모리 접근 방식의 차이에서 비롯됩니다.

첫 번째 코드

for (int i = 0; i < N - 1; i++) {
for (int j = i + 1; j < N; j++) {
if (arr[i] + arr[j] == M) result++;
}
}

    1.	시간 복잡도:
    •	이중 for 루프를 사용하므로 **시간 복잡도는 ￼**입니다.
    •	배열의 크기가 커질수록 (즉, ￼이 클수록) 실행 시간이 기하급수적으로 증가합니다.
    •	모든 가능한 두 숫자의 쌍을 검사해야 하므로 느립니다.
    2.	메모리 사용:
    •	크기가 15001인 정적 배열 arr만 사용하므로, 메모리 사용량은 적습니다.
    3.	성능:
    •	브루트 포스 방식이기 때문에 효율이 낮습니다.
    •	중복 계산이 많고, 한 번 사용된 값이 다시 다른 값과 계산에 포함되므로 비효율적입니다.

두 번째 코드

for (int i = 0; i < N; i++) {
int input;
cin >> input;
arr[input]++;
}

for (long long i = 1; i < sizeof(arr) / sizeof(arr[0]); i++) {
long long j = M - i;
if (j < 0) continue;
if (i == j) continue;
if (arr[i] == 0 || arr[j] == 0) continue;
arr[i] = 0;
arr[j] = 0;
result++;
}

    1.	시간 복잡도:
    •	첫 번째 루프: ￼ — 배열에 입력값을 저장.
    •	두 번째 루프: ￼, 여기서 ￼는 배열의 최대 크기 (10000001).
    •	**총 시간 복잡도는 ￼**입니다.
    •	이 방식은 두 숫자의 합을 빠르게 찾기 위해 배열 인덱스를 활용하며, 직접 값을 비교하는 대신 배열 조회로 해결합니다.
    2.	메모리 사용:
    •	크기가 10000001인 정적 배열 arr을 사용하므로, 메모리 사용량은 첫 번째 코드에 비해 큽니다.
    •	그러나 시간과 공간 간의 트레이드오프로, 더 많은 메모리를 사용하여 속도를 대폭 향상시켰습니다.
    3.	성능:
    •	두 번째 코드에서는 숫자의 합을 계산할 때 배열 인덱스를 활용해 상수 시간(￼)에 조회합니다.
    •	중복 계산이 없고, 사용한 값은 배열에서 제거하므로 불필요한 비교를 피합니다.
    •	이 접근 방식은 첫 번째 코드보다 훨씬 효율적입니다.

왜 첫 번째 코드는 느릴까?

    1.	이중 루프:
    •	￼이 커질수록 ￼개의 비교를 수행해야 하므로 계산량이 기하급수적으로 증가합니다.
    •	예를 들어, ￼이면 10,000,000,000번의 비교를 수행해야 할 수 있습니다.
    2.	불필요한 계산:
    •	모든 가능한 숫자 쌍을 검사하므로 중복 계산이 많습니다.
    3.	메모리 접근 방식:
    •	첫 번째 코드는 단순히 배열 값만을 비교하지만, 두 번째 코드는 배열의 인덱스를 직접 활용하여 검색 속도를 높입니다.

왜 두 번째 코드는 빠를까?

    1.	효율적인 합 계산:
    •	두 번째 코드에서는 배열의 인덱스를 활용하여 ￼에 해당하는 값을 상수 시간에 확인합니다.
    •	이로 인해 불필요한 반복을 줄이고, 원하는 쌍을 즉시 찾을 수 있습니다.
    2.	중복 제거:
    •	한 번 확인된 값은 배열에서 제거(arr[i] = 0;)하므로, 중복된 비교를 방지합니다.
    3.	시간 복잡도:
    •	첫 번째 코드의 ￼에 비해 두 번째 코드는 ￼로 훨씬 효율적입니다.

정리

    •	첫 번째 코드는 간단하지만 비효율적이며, 브루트 포스 방식으로 인해 큰 데이터셋에서 느립니다.
    •	두 번째 코드는 배열의 인덱스를 활용한 해시 테이블 방식과 유사한 접근법으로, 더 많은 메모리를 사용하지만 계산 속도가 매우 빠릅니다.
    •	이는 시간-공간 트레이드오프의 대표적인 사례로, 더 많은 메모리를 사용하여 실행 시간을 줄인 것입니다.
